@page "/"
@inject IJSRuntime JS
@inject HttpClient Http

<PageTitle>Diagram-JSON</PageTitle>

<div class="app-layout">
    <!-- Top Navbar -->
    <div class="navbar">
        <NavMenu OnNavMenuAction="HandleNavBarAction" />
    </div>

    <!-- Main Grid Area -->
    <div class="main-grid">
        <!-- Editor Panel -->
        <div class="left-panel" style="width:@editorPanelWidthPx">
            <StandaloneCodeEditor @ref="@monacoEditor"
            CssClass="json-editor"
            ConstructionOptions="EditorOptions"
            OnDidChangeModelContent="OnModelContentChange" />
        </div>

        <!-- Splitter -->
        <div class="splitter" @onmousedown="OnSplitterMouseDown"></div>

        <!-- Diagram Panel -->
        <div class="right-panel">
            <SfDiagramComponent @ref="diagram"
            Click="OnDiagramClick"
            Width="100%" Height="100%"
            Created="OnCreated"
            NodeCreating="OnNodeCreating"
            ConnectorCreating="OnConnectorCreating">
                <Layout Type="LayoutType.HierarchicalTree"
                SamePoint="false"
                Orientation="LayoutOrientation.LeftToRight"
                HorizontalSpacing="30"
                VerticalSpacing="100" />
                <SnapSettings Constraints="@snapConstraints">
                </SnapSettings>
                <DiagramTemplates>
                    <AnnotationTemplate>
                        @if (context is Annotation annotation)
                            {
                                if (annotation.UseTemplate && annotation.ID.Contains("LeafNode"))
                                {
                                    string[] lines = annotation.Content?.ToString()?.Split('\n', StringSplitOptions.RemoveEmptyEntries) ?? new string[0];
                                    <div style="height: 100%; width: 100%; display: flex; flex-direction: column; justify-content: center; align-items: start; margin-left: 10px">
                                        @foreach (var line in lines)
                                        {
                                            var colonIndex = line.IndexOf(':');
                                            var key = colonIndex >= 0 ? line.Substring(0, colonIndex + 1) : line;
                                            var rawValue = colonIndex >= 0 ? line.Substring(colonIndex + 1).Trim() : "";
                                            string valueStyle = "color: black;";
                                            bool isString = true;

                                            if (int.TryParse(rawValue, out _) || double.TryParse(rawValue, out _))
                                            {
                                                valueStyle = "color: brown;";
                                                isString = false;
                                            }
                                            else if (bool.TryParse(rawValue, out bool boolVal))
                                            {
                                                valueStyle = "color: green;";
                                                rawValue = boolVal.ToString().ToLower();
                                                isString = false;
                                            }

                                            string displayValue = isString && !string.IsNullOrWhiteSpace(rawValue) ? $"\"{rawValue}\"" : rawValue;

                                            <div style="display: flex; justify-content: center; align-items: center; padding-top: 3px; padding-bottom: 3px;">
                                                <span style="color: blue;">@key</span>
                                                @if (!string.IsNullOrWhiteSpace(displayValue))
                                                {
                                                    <span style="@valueStyle">&nbsp;@displayValue</span>
                                                }
                                            </div>
                                        }
                                    </div>
                                }
                            }
                        </AnnotationTemplate>
                    </DiagramTemplates>
                </SfDiagramComponent>
            </div>
        </div>

        <!-- Bottom Bar -->
        <div class="bottom-bar">
            <div class="bottom-bar-content">
                <span class="status-message">
                    @if (isJsonValidStatus)
                {
                    <span>
                        <Syncfusion.Blazor.Buttons.SfIcon IconCss="e-icons e-check status-icon" />
                        Valid JSON
                    </span>
                }
                else
                {
                    <span class="invalid-json">
                        <Syncfusion.Blazor.Buttons.SfIcon IconCss="e-icons e-close status-icon" />
                        Invalid JSON
                    </span>
                }
            </span>
            <span class="bottom-right">Nodes: @nodeCount</span>
        </div>
    </div>

</div>


<!-- Popup Dialog -->
<SfDialog Width="400px"
Header="Node Details"
ShowCloseIcon="true" 
IsModal="true" @bind-Visible="isDialogVisible">
    <DialogEvents OnOverlayModalClick="() => isDialogVisible = false"></DialogEvents>
    <DialogTemplates>
        <Content>
            <div style="padding: 10px; font-family:Consolas">
                <!-- Node Content Section -->
                <div style="margin-bottom: 15px;">
                    <label style="font-weight:bold; font-size:14px; display:block; margin-bottom:5px;">Content</label>
                    <div style="
                        background-color:#f8f8f8;
                        border-radius:5px;
                        position:relative;
                        font-size:14px;">
                        <!-- Scrollable content -->
                        <div style="padding:10px; overflow-x:auto; white-space:pre;">
                            @FormatNodeDataInPopup(selectedNodeContent)
                        </div>

                        <!-- Copy button stays fixed -->
                        <button @onclick="() => CopyNodeData(selectedNodeContent)" style="
                            position:absolute;
                            top:5px;
                            right:5px;
                            background:transparent;
                            border:none;
                            cursor:pointer;">
                            <span class="e-icons @(isNodeContentCopied ? "e-check" : "e-copy")"></span>
                        </button>
                    </div>

                </div>
                <!-- JSON Path Section -->
                <div>
                    <label style="font-weight:bold; font-size:14px; display:block; margin-bottom:5px;">JSON Path</label>
                    <div style="
                        background-color:#f8f8f8;
                        border-radius:5px;
                        position:relative;
                        font-size:14px;">
                        <!-- Scrollable content -->
                        <div style="padding:10px; overflow-x:auto; white-space:pre;">
                            @FormatNodeDataInPopup(selectedNodePath, true)
                        </div>

                        <!-- Copy button stays fixed -->
                        <button @onclick="() => CopyNodeData(selectedNodePath, true)" style="
                            position:absolute;
                            top:5px;
                            right:5px;
                            background:transparent;
                            border:none;
                            cursor:pointer;">
                            <span class="e-icons @(isNodePathCopied ? "e-check" : "e-copy")"></span>
                        </button>
                    </div>

                </div>
            </div>
        </Content>
    </DialogTemplates>
</SfDialog>

@code {
    #region fields

    private string editorPanelWidthPx = "300px";
    private bool resizing = false;
    private double startX = 0;
    private double startWidth = 300;
    private double windowWidth;

    private BlazorMonaco.Editor.StandaloneCodeEditor monacoEditor;
    private string jsonValue = "";

    private SfDiagramComponent diagram;
    private DiagramObjectCollection<NodeBase> nodeBase = new DiagramObjectCollection<NodeBase>();
    private DiagramData diagramData = new DiagramData();
    private SnapConstraints snapConstraints = SnapConstraints.ShowLines;

    private double expandCollapseIconWidth = 36;
    private int nodeCornerRadius = 3;
    private double minNodeWidth = 120;

    private bool isDialogVisible = false;
    private string selectedNodePath = "";
    private string selectedNodeContent = "";
    private bool isNodeContentCopied = false;
    private bool isNodePathCopied = false;

    private int nodeCount => diagramData.Nodes.Count;
    private bool isJsonValidStatus = true;
    #endregion

    #region Splitter

    private async Task OnSplitterMouseDown(MouseEventArgs e)
    {
        resizing = true;
        startX = e.ClientX;
        if (double.TryParse(editorPanelWidthPx.Replace("px", ""), out double w))
        {
            startWidth = w;
        }
        await JS.InvokeVoidAsync("attachResizeEvents", DotNetObjectReference.Create(this));
        windowWidth = await JS.InvokeAsync<double>("getWindowWidth");
    }

    [JSInvokable]
    public void OnMouseMove(double clientX)
    {
        if (resizing)
        {
            double newWidth = startWidth + (clientX - startX);
            double maxWidth = windowWidth * 0.4; // e.g. max 40% of window
            if (newWidth > maxWidth)
            {
                newWidth = maxWidth;
            }
            editorPanelWidthPx = newWidth + "px";
            InvokeAsync(StateHasChanged);
        }

    }

    [JSInvokable]
    public void OnMouseUp()
    {
        resizing = false;
    }

    #endregion

    #region Monaco Editor
    protected override void OnInitialized()
    {
        // Initialize the Monaco editor with a default JSON value.
        jsonValue = @"{
    ""TestingData"": {
        ""university"": {
            ""name"": ""Global Tech University"",
            ""location"": {
            ""city"": ""San Francisco"",
            ""state"": ""California"",
            ""country"": ""USA""
            }
        },
        ""administration"": {
            ""chancellor"": ""Dr. Marie Curie"",
            ""registrar"": ""Dr. Albert Einstein"",
            ""admissions_office"": {
            ""director"": ""Dr. Rosalind Franklin"",
            ""application_deadline"": ""2025-05-15""
            }
        },
        ""campus_facilities"": {
            ""library"": {
            ""name"": ""Tech Scholars Library"",
            ""books_available"": 50000,
            ""digital_resources"": true
            }
        }
    }
}";
    }

    private StandaloneEditorConstructionOptions EditorOptions(StandaloneCodeEditor _)
    {
        return new StandaloneEditorConstructionOptions
        {
            AutomaticLayout = true,
            Language = "json",
            Value = jsonValue,
            FormatOnPaste = true, 
            Placeholder = "Start Typing...",
            Minimap = new EditorMinimapOptions
            {
                Enabled = false
            },
            ScrollBeyondLastLine = false,
            Scrollbar = new EditorScrollbarOptions
            {
                VerticalScrollbarSize = 5,
                HorizontalScrollbarSize = 5,
            },
        };
    }

    private async Task OnModelContentChange(ModelContentChangedEvent e)
    {
        jsonValue = await monacoEditor.GetValue();
        if (string.IsNullOrEmpty(jsonValue.Trim()))
            isJsonValidStatus = true;
        else
            await ParseAndUpdateDiagram();
    }

    #endregion

    #region Diagram Component

    private async Task OnCreated()
    {
        await ParseAndUpdateDiagram();
    }

    private async Task OnNodeCreating(IDiagramObject obj)
    {
        if (obj is Node node)
        {
            node.Style = new ShapeStyle { Fill = "#ffffff", StrokeColor = "#bcbebf", StrokeWidth = 1 };

            if (node.ID == "main-root")
            {
                node.Width = 50;
                node.Height = 50;
                node.Shape = new BasicShape { Shape = NodeBasicShapes.Ellipse, Type = NodeShapes.Basic };
            }
            else
            {
                var (width, height) = await GetNodeSizeAsync((string)node?.AdditionalInfo["mergedContent"], (bool)node?.AdditionalInfo["isLeaf"], minNodeWidth);
                node.Width = width;
                node.Height = height;
                AdjustNodeAnnotationPosition(node);
                if (!(bool)node?.AdditionalInfo["isLeaf"])
                {
                    node.ExpandIcon = new DiagramExpandIcon()
                        {
                            Shape = DiagramExpandIcons.Minus,
                            Width = expandCollapseIconWidth,
                            Height = node.Height ?? 50,
                            HorizontalAlignment = HorizontalAlignment.Right,
                            CornerRadius = nodeCornerRadius,
                            BorderColor = "#bcbebf",
                        };
                    node.CollapseIcon = new DiagramCollapseIcon()
                        {
                            Shape = DiagramCollapseIcons.Plus,
                            Width = expandCollapseIconWidth,
                            Height = node.Height ?? 50,
                            HorizontalAlignment = HorizontalAlignment.Right,
                            CornerRadius = nodeCornerRadius,
                            BorderColor = "#bcbebf",
                        };
                }
                node.Shape = new BasicShape { Shape = NodeBasicShapes.Rectangle, Type = NodeShapes.Basic, CornerRadius = nodeCornerRadius };
            }
        }
    }

    private void OnConnectorCreating(IDiagramObject obj)
    {
        if (obj is Connector connector)
        {
            connector.Type = ConnectorSegmentType.Orthogonal;
            connector.CornerRadius = 15;
            connector.Style = new ShapeStyle { StrokeColor = "#bcbebf", StrokeWidth = 1.5 };
            connector.TargetDecorator = new DecoratorSettings
            {
                Shape = DecoratorShape.None
            };
        }
    }

    private async Task ParseAndUpdateDiagram()
    {
        try
        {
            using (JsonDocument doc = JsonDocument.Parse(jsonValue))
            {
                diagramData = JsonDiagramParser.ProcessData(doc.RootElement);
            }

            isJsonValidStatus = true;

            // Clear existing nodes and connectors
            diagram.Clear();
            nodeBase.Clear();

            foreach (var node in diagramData.Nodes)
            {
                nodeBase.Add(node);
            }
            foreach (var conn in diagramData.Connectors)
            {
                nodeBase.Add(conn);
            }

            // Add nodes and connectors to the diagram
            await diagram.AddDiagramElementsAsync(nodeBase);

            // Update the diagram layout
            await diagram.DoLayoutAsync();

            // Fit the diagram to the page
            diagram.FitToPage(new FitOptions() { Mode = FitMode.Both, Region = DiagramRegion.Content, CanZoomIn = true });
        }
        catch (Exception ex)
        {
            isJsonValidStatus = false;
            Console.WriteLine($"Error parsing JSON: {ex.Message}");
        }
    }

    private async Task<(double width, double height)> GetNodeSizeAsync(string content, bool isLeaf, double minWidth)
    {
        var result = await JS.InvokeAsync<Dictionary<string, double>>("getTextSize", content);

        double iconExtra = isLeaf ? 0 : expandCollapseIconWidth;
        double width = result["width"] + iconExtra;

        width = Math.Max(minWidth, width);  

        return (width, result["height"]);
    }


    private void AdjustNodeAnnotationPosition(Node node)
    {
        int padding = 10;

        if (node.Annotations == null || node.Annotations.Count == 0)
            return;

        if (node.Annotations.Count >= 2)
        {
            // Left-align the first annotation
            var annotation1 = node.Annotations[0];
            annotation1.ID = "Text";
            annotation1.Offset = new DiagramPoint { X = 0, Y = 0.5 };
            annotation1.HorizontalAlignment = HorizontalAlignment.Left;
            annotation1.Style = new TextStyle
            {
                Color = "blue",
                TextAlign = TextAlign.Left,
            };
            annotation1.Margin = new DiagramThickness { Left = padding };

            // Right-align the second annotation
            var annotation2 = node.Annotations[1];
            annotation1.ID = "Count";
            annotation2.Offset = new DiagramPoint { X = 1, Y = 0.5 };
            annotation2.HorizontalAlignment = HorizontalAlignment.Right;
            annotation2.Style = new TextStyle
            {
                Color = "gray",
                TextAlign = TextAlign.Right,
            };
            annotation2.Margin = new DiagramThickness { Right = expandCollapseIconWidth + padding };
        }
        else if (node.Annotations.Count == 1 && (bool)node?.AdditionalInfo["isLeaf"])
        {
            var leafNodeAnnotation = node.Annotations[0];
            leafNodeAnnotation.ID = "LeafNode";
            leafNodeAnnotation.UseTemplate = true;
            leafNodeAnnotation.Width = node.Width;
            leafNodeAnnotation.Height = node.Height;
        }
    }
    #endregion

    #region Popup Dialog

    private void OnDiagramClick(ClickEventArgs args)
    {
        if (args.Element is Node node && node.Data != null && args.ActualObject != null)
        {
            var nodeData = node.Data.GetType().GetProperty("actualdata")?.GetValue(node.Data, null)?.ToString();
            var path = node.Data.GetType().GetProperty("path")?.GetValue(node.Data, null)?.ToString();

            if (!string.IsNullOrEmpty(nodeData) && !string.IsNullOrEmpty(path))
            {
                ShowNodePopup(nodeData, path);
            }
        }
    }

    private void ShowNodePopup(string nodeContent, string nodePath)
    {
        selectedNodeContent = nodeContent;
        selectedNodePath = nodePath;
        isDialogVisible = true;
    }
    private RenderFragment FormatNodeDataInPopup(string content, bool isPath = false) => __builder =>
    {
        if (string.IsNullOrWhiteSpace(content))
            return;

        var formattedLines = FormatJsonLines(content);
        int seq = 0;

        // If not a json data
        if (formattedLines.Count == 0)
        {
            __builder.OpenElement(seq++, "div");
            if (isPath)
            {
                __builder.AddContent(seq++, AddCurlyBracesAroundRoot(content));
            }
            else
            {
                __builder.AddAttribute(seq++, "style", "color:#4CAF50;");
                __builder.AddContent(seq++, '"' +  content + '"');
            }
            __builder.CloseElement();
        }
        // If a json data
        else if(formattedLines.Count > 0)
        {
            __builder.OpenElement(seq++, "div");
            __builder.AddContent(seq++, "{");
            __builder.CloseElement();

            foreach (var (key, value, hasComma) in formattedLines)
            {
                __builder.OpenElement(seq++, "div");

                __builder.OpenElement(seq++, "span");
                __builder.AddAttribute(seq++, "style", "color:#9C27B0; font-weight:bold; margin-right:5px; margin-left:14px;");
                __builder.AddContent(seq++, key);
                __builder.CloseElement();

                __builder.OpenElement(seq++, "span");
                __builder.AddAttribute(seq++, "style", "margin-right:5px;");
                __builder.AddContent(seq++, ":");
                __builder.CloseElement();

                __builder.OpenElement(seq++, "span");
                __builder.AddAttribute(seq++, "style", "color:#4CAF50;");
                __builder.AddContent(seq++, value);
                __builder.CloseElement();

                if (hasComma)
                {
                    __builder.AddContent(seq++, ",");
                }

                __builder.CloseElement();
            }

            __builder.OpenElement(seq++, "div");
            __builder.AddContent(seq++, "}");
            __builder.CloseElement();
        }
    };

    private static List<(string, string, bool)> FormatJsonLines(string content)
    {
        if (string.IsNullOrWhiteSpace(content))
            return new List<(string, string, bool)>();

        var lines = content.Split('\n');
        var formattedLines = new List<(string, string, bool)>();

        for (int i = 0; i < lines.Length; i++)
        {
            var parts = lines[i].Split(new char[] { ':' }, 2, StringSplitOptions.RemoveEmptyEntries);

            if (parts.Length == 2)
            {
                var key = $"\"{parts[0].Trim()}\"";
                var value = parts[1].Trim();

                bool isString = !int.TryParse(value, out _) && !double.TryParse(value, out _) && !bool.TryParse(value, out _);
                if (isString)
                {
                    value = $"\"{value}\"";
                }

                bool isLast = i == lines.Length - 1;
                formattedLines.Add((key, value, !isLast));
            }
        }
        return formattedLines;
    }

    private string AddCurlyBracesAroundRoot(string input)
    {
        const string rootKeyword = "Root";
        if (input.StartsWith(rootKeyword))
        {
            return "{" + rootKeyword + "}" + input.Substring(rootKeyword.Length);
        }
        return input;
    }

    private async Task CopyNodeData(string data, bool isPath = false)
    {

        if (isPath)
        {
            await JS.InvokeVoidAsync("navigator.clipboard.writeText", AddCurlyBracesAroundRoot(data));
            isNodePathCopied = true;        
        }
        else
        {
            var formattedString = GetFormattedJsonString(data);
            await JS.InvokeVoidAsync("navigator.clipboard.writeText", formattedString);        
            isNodeContentCopied = true;
        }

        StateHasChanged();

        await Task.Delay(1500);

        StateHasChanged();

        if (isPath)
            isNodePathCopied = false;
        else
            isNodeContentCopied = false;
    }

    private static string GetFormattedJsonString(string content)
    {
        var formattedLines = FormatJsonLines(content);
        var result = "{\n";

        foreach (var (key, value, hasComma) in formattedLines)
        {
            result += $"    {key}: {value}{(hasComma ? "," : "")}\n";
        }

        result += "}";
        return result;
    }
    #endregion

    #region NavMenu Actions

    private async Task HandleNavBarAction(string action)
    {
        switch (action)
        {
            case "import-json":
            case "export-json":
                await HandleImportExport(action);
                break;
            case "toggle-grid":
                ToggleGridLines();
                break;

        }

    }

    private async Task HandleImportExport(string action)
    {
        if (action == "import-json")
        {
            try
            {
                var objRef = DotNetObjectReference.Create(this);
                await JS.InvokeVoidAsync("importJsonFromFile", objRef);
            }
            catch (JSException ex)
            {
                Console.WriteLine("Import failed: " + ex.Message);
            }
        }
        else if (action == "export-json")
        {
            try
            {
                string jsonToExport = jsonValue ?? "{}";
                await JS.InvokeVoidAsync("exportJsonFile", jsonToExport, "Diagram.json");
            }
            catch (JSException ex)
            {
                Console.WriteLine("Export failed: " + ex.Message);
            }
        }
    }

    [JSInvokable]
    public async Task ReceiveImportedJson(string jsonContent)
    {
        jsonValue = jsonContent;
        await monacoEditor.SetValue(jsonContent);
    }

    private void ToggleGridLines()
    {
        if (snapConstraints == SnapConstraints.ShowLines)
            snapConstraints = SnapConstraints.None;
        else
            snapConstraints = SnapConstraints.ShowLines;
    }
    #endregion
}

<style>
    html, body {
        height: 100%;
        margin: 0;
        padding: 0;
        overflow: hidden;
        font-family: Consolas,"Segoe UI", Tahoma, sans-serif;
    }

    .app-layout {
        display: grid;
        grid-template-rows: auto 1fr auto;
        height: 100vh;
        width: 100vw;
    }

    /* Top Nav */
    .navbar {
        height: 48px;
        background-color: #f8f8f8;
        z-index: 10;
    }

    /* Main Grid */
    .main-grid {
        display: grid;
        grid-template-columns: auto 6px 1fr;
        overflow: hidden;
    }

    /* Editor */
    .left-panel {
        height: 100%;
        overflow: hidden;
    }

    .json-editor {
        height: 100%;
    }

    /* Splitter */
    .splitter {
        background-color: #ddd;
        cursor: col-resize;
        height: 100%;
    }

    /* Diagram */
    .right-panel {
        height: 100%;
        overflow: hidden;
    }

    /* Bottom Bar */
    .bottom-bar {
        height: 26px;
        background-color: #f1f1f1;
        border-top: 1px solid #ccc;
        display: flex;
        align-items: center;
        justify-content: center;
    }

    .bottom-bar-content {
        width: 100%;
        display: flex;
        align-items: center;
        padding: 0 20px;
        font-size: 13px;
        color: #333;
        gap: 20px;
    }

    .bottom-right {
        margin-left: auto;
    }

    .status-message {
        display: flex;
        align-items: center;
        gap: 6px;
        font-size: 14px;
    }

    .status-icon {
        font-size: 16px;
        vertical-align: middle;
        margin-right: -3px;
    }

    .invalid-json {
        color: red;
    }

</style>