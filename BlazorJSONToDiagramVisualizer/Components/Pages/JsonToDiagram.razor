@page "/"
@inject IJSRuntime JS
@inject HttpClient Http
@inject ThemeService ThemeService

<PageTitle>Diagram-JSON</PageTitle>

<div class="app-layout">
    @* Top Navbar *@
    <div class="navbar">
        <NavMenu OnNavMenuAction="HandleNavBarAction" />
    </div>

    @* Main Area  *@
    <div class="main-grid">
        @* Editor Panel  *@
        <div class="left-panel @(ThemeService.CurrentTheme)" style="width:@editorPanelWidthPx">
            <StandaloneCodeEditor @ref="@monacoEditor"
            CssClass="json-editor"
            ConstructionOptions="EditorOptions"
            OnDidChangeModelContent="OnModelContentChange" />
        </div>

        @* Splitter *@
        <div class="splitter @(ThemeService.CurrentTheme)" @onmousedown="OnSplitterMouseDown"></div>

        @* Diagram Panel  *@
        <div class="right-panel scroll-hide @(ThemeService.CurrentTheme)">

            @* Hamburger Menu *@
            <HamburgerMenu OnHamburgerMenuAction="HandleHamburgerMenuAction" IsGraphCollapsed="@isGraphCollapsed"/>

            @* Diagram Control *@
            <SfDiagramComponent @ref="diagram"
            InteractionController="DiagramInteractions.ZoomPan"
            Click="OnDiagramClick"
            Width="100%" Height="100%"
            Created="OnCreated"
            NodeCreating="OnNodeCreating"
            ConnectorCreating="OnConnectorCreating">
                <Layout Type="LayoutType.HierarchicalTree"
                SamePoint="false"
                @bind-Orientation ="@layoutOrientation"
                HorizontalSpacing="30"
                VerticalSpacing="100" />
                <SnapSettings @bind-Constraints ="@snapConstraints">
                    <HorizontalGridLines @bind-LineColor="@ThemeService.CurrentThemeSettings.GridlinesColor"/>
                    <VerticalGridLines @bind-LineColor="@ThemeService.CurrentThemeSettings.GridlinesColor"/>
                </SnapSettings>
            </SfDiagramComponent>

            @* Tool Bar Control *@
            <DiagramToolBar OnToolBarAction="HandleToolBarAction" />

        </div>
    </div>

    @* Bottom Status Bar *@
    <div class="bottom-bar @(ThemeService.CurrentTheme)">
        <div class="bottom-bar-content @(ThemeService.CurrentTheme)">
            <span class="status-message">
                @if (isJsonValidStatus)
                {
                    <span>
                        <Syncfusion.Blazor.Buttons.SfIcon IconCss="e-icons e-check-3 status-icon" />
                        Valid JSON
                    </span>
                }
                else
                {
                    <span class="invalid-json">
                        <Syncfusion.Blazor.Buttons.SfIcon IconCss="e-icons e-close-6 status-icon" />
                        Invalid JSON
                    </span>
                }
            </span>
            <span class="bottom-right">Nodes: @nodeCount</span>
        </div>
    </div>

</div>

@* Node Data Popup Dialog  *@
<SfDialog Width="400px"
Header="Node Details"
ShowCloseIcon="true" 
IsModal="true" @bind-Visible="isDialogVisible">
    <DialogEvents OnOverlayModalClick="() => isDialogVisible = false"></DialogEvents>
    <DialogTemplates>
        <Content>
            <div>
                <!-- Node Content Section -->
                <div style="margin-bottom: 15px;">
                    <label style="font-weight:500; font-size:14px; display:block; margin-bottom:5px;">Content</label>
                    <div style="
                        background-color: @(ThemeService.CurrentThemeSettings.PopupContentBGColor);
                        border-radius:5px;
                        position:relative;
                        font-size:14px;">
                        <!-- Scrollable content -->
                        <div style="padding:10px; overflow-x:auto; white-space:pre; font-family:Consolas">
                            @FormatNodeDataInPopup(selectedNodeContent)
                        </div>

                        <!-- Copy button stays fixed -->
                        <button @onclick="() => CopyNodeData(selectedNodeContent)" style="
                            position:absolute;
                            top:5px;
                            right:5px;
                            background:transparent;
                            border:none;
                            cursor:pointer;">
                            <span class="e-icons @(isNodeContentCopied ? "e-check" : "e-copy")" style="color:#6C757D"></span>
                        </button>
                    </div>

                </div>
                <!-- JSON Path Section -->
                <div>
                    <label style="font-weight:500; font-size:14px; display:block; margin-bottom:5px;">JSON Path</label>
                    <div style="
                        background-color: @(ThemeService.CurrentThemeSettings.PopupContentBGColor);
                        border-radius:5px;
                        position:relative;
                        font-size:14px;">
                        <!-- Scrollable content -->
                        <div style="padding:10px; overflow-x:auto; white-space:pre; font-family:Consolas">
                            @FormatNodeDataInPopup(selectedNodePath, true)
                        </div>

                        <!-- Copy button stays fixed -->
                        <button @onclick="() => CopyNodeData(selectedNodePath, true)" style="
                            position:absolute;
                            top:5px;
                            right:5px;
                            background:transparent;
                            border:none;
                            cursor:pointer;">
                            <span class="e-icons @(isNodePathCopied ? "e-check" : "e-copy")" style="color:#6C757D"></span>
                        </button>
                    </div>

                </div>
            </div>
        </Content>
    </DialogTemplates>
</SfDialog>

@* Export as Image Popup Dialog  *@
<ExportImageDialog @ref="exportDialog" OnExport="HandleExportDiagramAsImage" />

@code {
    #region fields

    private string editorPanelWidthPx = "300px";
    private bool resizing = false;
    private double startX = 0;
    private double startWidth = 300;
    private double windowWidth;

    private BlazorMonaco.Editor.StandaloneCodeEditor monacoEditor;
    private string jsonValue = "";

    private SfDiagramComponent diagram;
    private DiagramObjectCollection<NodeBase> nodeBase = new DiagramObjectCollection<NodeBase>();
    private DiagramData diagramData = new DiagramData();
    private SnapConstraints snapConstraints = SnapConstraints.ShowLines;
    private bool showChildCount = true;
    private bool showExpandCollapseIcon = true;
    private LayoutOrientation[] orientationsList =
    {
        LayoutOrientation.LeftToRight,
        LayoutOrientation.TopToBottom,
        LayoutOrientation.RightToLeft,
        LayoutOrientation.BottomToTop
    };
    private int currentOrientationIndex = 0;
    private LayoutOrientation layoutOrientation = LayoutOrientation.LeftToRight;

    private double expandCollapseIconWidth = 36;
    private int nodeCornerRadius = 2;
    private double minNodeWidth = 120;

    private bool isDialogVisible = false;
    private string selectedNodePath = "";
    private string selectedNodeContent = "";
    private bool isNodeContentCopied = false;
    private bool isNodePathCopied = false;

    private int nodeCount => diagramData.Nodes.Count;
    private bool isJsonValidStatus = true;
    private bool isGraphCollapsed = false;
    private ExportImageDialog exportDialog;

    #endregion

    #region Splitter

    private async Task OnSplitterMouseDown(MouseEventArgs e)
    {
        resizing = true;
        startX = e.ClientX;
        if (double.TryParse(editorPanelWidthPx.Replace("px", ""), out double w))
        {
            startWidth = w;
        }
        await JS.InvokeVoidAsync("attachResizeEvents", DotNetObjectReference.Create(this));
        windowWidth = await JS.InvokeAsync<double>("getWindowWidth");
    }

    [JSInvokable]
    public void OnMouseMove(double clientX)
    {
        if (resizing)
        {
            double newWidth = startWidth + (clientX - startX);
            double maxWidth = windowWidth * 0.4; // e.g. max 40% of window
            if (newWidth > maxWidth)
            {
                newWidth = maxWidth;
            }
            editorPanelWidthPx = newWidth + "px";
            InvokeAsync(StateHasChanged);
        }

    }

    [JSInvokable]
    public void OnMouseUp()
    {
        resizing = false;
    }

    #endregion

    #region Monaco Editor

    protected override void OnInitialized()
    {
        // Initialize the Monaco editor with a default JSON value.
        jsonValue = @"{
    ""TestingData"": {
        ""university"": {
            ""name"": ""Global Tech University"",
            ""location"": {
            ""city"": ""San Francisco"",
            ""state"": ""California"",
            ""country"": ""USA""
            }
        },
        ""administration"": {
            ""chancellor"": ""Dr. Marie Curie"",
            ""registrar"": ""Dr. Albert Einstein"",
            ""admissions_office"": {
            ""director"": ""Dr. Rosalind Franklin"",
            ""application_deadline"": ""2025-05-15""
            }
        },
        ""campus_facilities"": {
            ""library"": {
            ""name"": ""Tech Scholars Library"",
            ""books_available"": 50000,
            ""digital_resources"": true
            }
        }
    }
}";

        ThemeService.CurrentThemeSettings = new ThemeSettings("light");
    }

    private StandaloneEditorConstructionOptions EditorOptions(StandaloneCodeEditor _)
    {
        return new StandaloneEditorConstructionOptions
        {
            AutomaticLayout = true,
            Language = "json",
            Value = jsonValue,
            FormatOnPaste = true, 
            Placeholder = "Start Typing...",
            Minimap = new EditorMinimapOptions
            {
                Enabled = false
            },
            ScrollBeyondLastLine = false,
            Scrollbar = new EditorScrollbarOptions
            {
                VerticalScrollbarSize = 5,
                HorizontalScrollbarSize = 5,
            },
        };
    }

    private async Task OnModelContentChange(ModelContentChangedEvent e)
    {
        jsonValue = await monacoEditor.GetValue();
        if (string.IsNullOrEmpty(jsonValue.Trim()))
            isJsonValidStatus = true;
        else
            await ParseAndUpdateDiagram();
    }

    #endregion

    #region Diagram Component

    private async Task OnCreated()
    {
        await ParseAndUpdateDiagram();
    }

    private async Task OnNodeCreating(IDiagramObject obj)
    {
        if (obj is Node node)
        {
            node.Constraints = (NodeConstraints.Default | NodeConstraints.HideThumbs | NodeConstraints.ReadOnly) & ~(NodeConstraints.Rotate | NodeConstraints.Resize | NodeConstraints.Delete);
            node.Style = new ShapeStyle { Fill = ThemeService.CurrentThemeSettings.NodeFillColor, StrokeColor = ThemeService.CurrentThemeSettings.NodeStrokeColor, StrokeWidth = 1 };

            if (node.ID == "main-root")
            {
                node.Width = 40;
                node.Height = 40;
                // if multi root node then ellipse shape
                node.Shape = new BasicShape { Shape = NodeBasicShapes.Ellipse, Type = NodeShapes.Basic };
            }
            else
            {
                // if normal node then rectangle shape
                node.Shape = new BasicShape { Shape = NodeBasicShapes.Rectangle, Type = NodeShapes.Basic, CornerRadius = nodeCornerRadius };

                var additionalInfo = node?.AdditionalInfo;
                if (additionalInfo != null
                    && additionalInfo.TryGetValue("mergedContent", out var mergedContent)
                    && additionalInfo.TryGetValue("isLeaf", out var isLeafObj)
                    && bool.TryParse(isLeafObj?.ToString(), out bool isLeaf))
                {
                    var (width, height) = await GetNodeSizeAsync((string)mergedContent, isLeaf, minNodeWidth);
                    node.Width = width;
                    node.Height = height;
                }

                await UpdateNodeAnnotation(node);

                if (additionalInfo != null && !(bool)additionalInfo["isLeaf"] & showExpandCollapseIcon)
                {
                    CreateExpandCollapseIcon(node, isExpandIcon: true);
                    CreateExpandCollapseIcon(node, isExpandIcon: false);
                }
                else
                {
                    node.ExpandIcon = null;
                    node.CollapseIcon = null;
                }
            }
        }
    }

    private void CreateExpandCollapseIcon(Node node, bool isExpandIcon)
    {
        if (isExpandIcon)
        {
            node.ExpandIcon = new DiagramExpandIcon()
            {
                Shape = DiagramExpandIcons.Minus,
                Width = expandCollapseIconWidth,
                Height = node.Height ?? 50,
                HorizontalAlignment = HorizontalAlignment.Right,
                CornerRadius = nodeCornerRadius,
                BorderColor = ThemeService.CurrentThemeSettings.ExpandIconBorder,
                Fill = ThemeService.CurrentThemeSettings.ExpandIconFillColor
            };
            UpdateExpandCollapseIconOffset(node.ExpandIcon);
        }
        else
        {
            node.CollapseIcon = new DiagramCollapseIcon()
            {
                Shape = DiagramCollapseIcons.Plus,
                Width = expandCollapseIconWidth,
                Height = node.Height ?? 50,
                HorizontalAlignment = HorizontalAlignment.Right,
                CornerRadius = nodeCornerRadius,
                BorderColor = ThemeService.CurrentThemeSettings.ExpandIconBorder,
                Fill = ThemeService.CurrentThemeSettings.ExpandIconFillColor, 
            };
            UpdateExpandCollapseIconOffset(node.CollapseIcon);
        }
    }

    private void UpdateExpandCollapseIconOffset(DiagramIcon icon)
    {
        if (layoutOrientation == LayoutOrientation.LeftToRight || layoutOrientation == LayoutOrientation.RightToLeft)
        {
            icon.OffsetX = 0.5;
            icon.OffsetY = 1;
            if (layoutOrientation == LayoutOrientation.RightToLeft)
            {
                icon.OffsetX = 0.5;
                icon.OffsetY = 0;
            }
        }
        else if (layoutOrientation == LayoutOrientation.TopToBottom || layoutOrientation == LayoutOrientation.BottomToTop)
        {
            icon.OffsetX = 1;
            icon.OffsetY = 0.5;
        }
    }

    private void OnConnectorCreating(IDiagramObject obj)
    {
        if (obj is Connector connector)
        {
            connector.Constraints = (ConnectorConstraints.Default | ConnectorConstraints.ReadOnly) & ~(ConnectorConstraints.DragSourceEnd | ConnectorConstraints.DragTargetEnd | ConnectorConstraints.Select);
            UpdateConnectorStyle(connector);
        }
    }

    private void UpdateConnectorStyle(Connector connector)
    {
        connector.Type = ConnectorSegmentType.Orthogonal;
        connector.CornerRadius = 15;
        connector.Style = new ShapeStyle { StrokeColor = ThemeService.CurrentThemeSettings.ConnectorStrokeColor, StrokeWidth = 1.5 };
        connector.TargetDecorator = new DecoratorSettings
        {
            Shape = DecoratorShape.None
        };
    }

    private async Task ParseAndUpdateDiagram()
    {
        try
        {
            using (JsonDocument doc = JsonDocument.Parse(jsonValue))
            {
                diagramData = JsonDiagramParser.ProcessData(doc.RootElement);
            }

            isJsonValidStatus = true;

            diagram.Clear();
            nodeBase.Clear();
            diagram.Nodes.Clear();
            diagram.Connectors.Clear();

            foreach (var node in diagramData.Nodes)
            {
                nodeBase.Add(node);
                CreateAnnotationsForLeafNode(node);
            }
            foreach (var conn in diagramData.Connectors)
            {
                nodeBase.Add(conn);
            }

            await diagram.AddDiagramElementsAsync(nodeBase);
            await diagram.DoLayoutAsync();
            await UpdateDefaultNodeStyles();

            diagram.FitToPage(new FitOptions() { Mode = FitMode.Both, Region = DiagramRegion.Content, CanZoomIn = true });
        }
        catch (Exception ex)
        {
            isJsonValidStatus = false;
            Console.WriteLine($"Error parsing JSON: {ex.Message}");
        }
    }

    private void CreateAnnotationsForLeafNode(Node node)
    {
        if (node == null || node.Annotations == null || node.Annotations.Count == 0)
            return;

        // Check if the node is a leaf
        bool isLeaf = node.AdditionalInfo != null &&
                      node.AdditionalInfo.ContainsKey("isLeaf") &&
                      (bool)node.AdditionalInfo["isLeaf"];

        if (!isLeaf) return;

        var originalContent = node.Annotations[0].Content?.ToString();
        if (string.IsNullOrWhiteSpace(originalContent))
            return;

        node.Annotations.Clear();

        var lines = originalContent.Split('\n', StringSplitOptions.RemoveEmptyEntries);
        var totalLines = lines.Length;
        var spacingY = totalLines > 0 ? 1.0 / (totalLines + 1) : 0.5;
        var currentLine = 1;

        foreach (var line in lines)
        {
            var splitIndex = line.IndexOf(':');
            string key = line;
            string value = "";
            if (splitIndex > -1)
            {
                key = line.Substring(0, splitIndex + 1).Trim();
                value = line.Substring(splitIndex + 1).Trim();
            }

            double offsetY = currentLine * spacingY;

            // Add Key annotation
            node.Annotations.Add(new ShapeAnnotation
            {
                ID = "Key" + line,
                Content = key,
                Offset = new DiagramPoint { X = 0, Y = offsetY },
            });

            // Add Value annotation (only if there's a value)
            if (!string.IsNullOrEmpty(value))
            {
                node.Annotations.Add(new ShapeAnnotation
                {
                    ID = "Value" + line,
                    Content = value,
                    Offset = new DiagramPoint { X = 1, Y = offsetY },
                });
            }
            currentLine++;
        }
    }

    private async Task<(double width, double height)> GetNodeSizeAsync(string content, bool isLeaf, double minWidth)
    {
        if (!isLeaf && !showChildCount)
        {
            content = RemoveCountValue(content);
        }

        double iconExtra = isLeaf ? 0 : showExpandCollapseIcon ? expandCollapseIconWidth : 0;

        var result = await JS.InvokeAsync<Dictionary<string, double>>("getTextSize", content);

        double width = result["width"] + iconExtra;

        width = Math.Max(minWidth, width);  

        return (width, result["height"]);
    }

    private string RemoveCountValue(string input)
    {
        // Regular expression to match contents within curly braces including the braces
        string pattern = @"\{.*?\}";
        // Replace the matched contents with an empty string
        return System.Text.RegularExpressions.Regex.Replace(input, pattern, "").Trim();
    }

    private async Task UpdateNodeAnnotation(Node node, bool isThemeChange = false)
    {
        int padding = 10;

        if (node.Annotations == null || node.Annotations.Count == 0)
            return;

        bool isLeaf = node.AdditionalInfo != null && node.AdditionalInfo.ContainsKey("isLeaf") && (bool)node.AdditionalInfo["isLeaf"];

        if (node.Annotations.Count >= 2 && !isLeaf)
        {
            var keyAnnotation = node.Annotations[0];
            keyAnnotation.ID = "Key";
            keyAnnotation.Style = new TextStyle
            {
                Color = ThemeService.CurrentThemeSettings.TextKeyColor,
                TextAlign = TextAlign.Left,
                FontFamily = "Consolas"
            };

            var countAnnotation = node.Annotations[1];
            countAnnotation.ID = "Count";
            countAnnotation.Style = new TextStyle
            {
                Color = ThemeService.CurrentThemeSettings.TextValueColor,
                TextAlign = TextAlign.Right,
                FontFamily = "Consolas"
            };

            if (showChildCount)
            {
                // Show Count Annotation
                countAnnotation.Visibility = true;

                // Left-align the Key annotation
                keyAnnotation.Offset = new DiagramPoint { X = 0, Y = 0.5 };
                keyAnnotation.HorizontalAlignment = HorizontalAlignment.Left;
                keyAnnotation.Margin = new DiagramThickness { Left = padding };

                // Right-align the Count annotation
                countAnnotation.Offset = new DiagramPoint { X = 1, Y = 0.5 };
                countAnnotation.HorizontalAlignment = HorizontalAlignment.Right;
                countAnnotation.Margin = new DiagramThickness
                {
                    Right = (showExpandCollapseIcon ? expandCollapseIconWidth : 0) + padding
                };
            }
            else
            {
                if (showExpandCollapseIcon)
                {
                    keyAnnotation.Offset = new DiagramPoint { X = 0, Y = 0.5 };
                    keyAnnotation.HorizontalAlignment = HorizontalAlignment.Auto;
                    keyAnnotation.Margin = new DiagramThickness { Left = padding };
                }
                else
                {
                    keyAnnotation.Offset = new DiagramPoint { X = 0.5, Y = 0.5 };
                    keyAnnotation.HorizontalAlignment = HorizontalAlignment.Center;
                    keyAnnotation.Margin = new DiagramThickness();
                }
                // Hide Count Annotation
                countAnnotation.Visibility = false;
            }
        }
        else if (isLeaf)
        {
            await AdjustLeafNodeAnnotations(node, padding, isThemeChange);
        }
    }

    private async Task AdjustLeafNodeAnnotations(Node node, int padding, bool isThemeChange)
    {
        double nodeWidth = node.Width ?? 100;
        double keyMeasuredWidth = 0.0;

        foreach (var annotation in node.Annotations)
        {
            var size = await JS.InvokeAsync<Dictionary<string, double>>("getTextSize", annotation.Content, "12px Consolas");
            double contentWidth = size["width"];
            string rawValue = annotation.Content?.ToString() ?? "";

            if (annotation.ID.StartsWith("Key"))
            {
                annotation.Offset = new DiagramPoint
                {
                    X = padding / nodeWidth,
                    Y = annotation.Offset.Y
                };
                annotation.HorizontalAlignment = HorizontalAlignment.Left;
                keyMeasuredWidth = contentWidth;
            }
            else if (annotation.ID.StartsWith("Value"))
            {
                string displayValue = FormatDisplayValue(rawValue);
                annotation.Content = displayValue;
                annotation.Offset = new DiagramPoint
                {
                    X = (padding + 2 + keyMeasuredWidth) / nodeWidth,
                    Y = annotation.Offset.Y
                };
                annotation.HorizontalAlignment = HorizontalAlignment.Left;
                keyMeasuredWidth = 0;
            }

            ApplyAnnotationStyle(annotation, rawValue);
        }
    }

    private string DetermineValueStyle(string rawValue)
    {
        if (int.TryParse(rawValue, out _) || double.TryParse(rawValue, out _))
        {
            return ThemeService.CurrentThemeSettings.NumericColor;
        }
        else if (bool.TryParse(rawValue, out bool boolVal))
        {
            return boolVal ? ThemeService.CurrentThemeSettings.BooleanColor : "red";
        }
        return ThemeService.CurrentThemeSettings.TextValueColor;
    }

    private string FormatDisplayValue(string rawValue)
    {
        bool isString = !int.TryParse(rawValue, out _) && !double.TryParse(rawValue, out _) && !bool.TryParse(rawValue, out bool boolVal);

        if (!isString)
        {
            if (bool.TryParse(rawValue, out boolVal))
            {
                return boolVal.ToString().ToLower();
            }
        }

        if (isString && !string.IsNullOrWhiteSpace(rawValue))
        {
            if (rawValue.StartsWith("\"") && rawValue.EndsWith("\""))
            {
                return rawValue;
            }
            return $"\"{rawValue}\"";
        }

        return rawValue;
    }

    private void ApplyAnnotationStyle(Annotation annotation, string rawValue)
    {
        if (annotation.ID.StartsWith("Key"))
        {
            annotation.Style = new TextStyle
            {
                Color = ThemeService.CurrentThemeSettings.TextKeyColor,
                FontFamily = "Consolas"
            };
        }
        else if (annotation.ID.StartsWith("Value"))
        {
            string valueStyle = DetermineValueStyle(rawValue);
            annotation.Style = new TextStyle
            {
                Color = valueStyle,
                FontFamily = "Consolas"
            };
        }
        else if (annotation.ID.StartsWith("Count"))
        {
            annotation.Style = new TextStyle
            {
                Color = ThemeService.CurrentThemeSettings.TextValueColor,
                FontFamily = "Consolas"
            };
        }
    }

    #endregion

    #region Popup Dialog

    private void OnDiagramClick(ClickEventArgs args)
    {
        if (args.Element is Node node && node.Data != null)
        {
            var nodeData = node.Data.GetType().GetProperty("actualdata")?.GetValue(node.Data, null)?.ToString();
            var path = node.Data.GetType().GetProperty("path")?.GetValue(node.Data, null)?.ToString();

            if (!string.IsNullOrEmpty(nodeData) && !string.IsNullOrEmpty(path))
            {
                selectedNodeContent = nodeData;
                selectedNodePath = path;
                isDialogVisible = true;
            }
        }
    }

    private RenderFragment FormatNodeDataInPopup(string content, bool isPath = false) => __builder =>
    {
        if (string.IsNullOrWhiteSpace(content))
            return;

        var formattedLines = FormatJsonLines(content);
        int seq = 0;

        // If not a json data
        if (formattedLines.Count == 0)
        {
            __builder.OpenElement(seq++, "div");
            if (isPath)
            {
                __builder.AddContent(seq++, AddCurlyBracesAroundRoot(content));
            }
            else
            {
                __builder.AddAttribute(seq++, "style", $"color:{ThemeService.CurrentThemeSettings.PopupValueColor};");
                __builder.AddContent(seq++, '"' +  content + '"');
            }
            __builder.CloseElement();
        }
        // If a json data
        else if(formattedLines.Count > 0)
        {
            __builder.OpenElement(seq++, "div");
            __builder.AddContent(seq++, "{");
            __builder.CloseElement();

            foreach (var (key, value, hasComma) in formattedLines)
            {
                __builder.OpenElement(seq++, "div");

                __builder.OpenElement(seq++, "span");
                __builder.AddAttribute(seq++, "style", $"color:{ThemeService.CurrentThemeSettings.PopupKeyColor}; font-weight:550; margin-right:5px; margin-left:14px;"); __builder.AddContent(seq++, key);
                __builder.CloseElement();

                __builder.OpenElement(seq++, "span");
                __builder.AddAttribute(seq++, "style", "margin-right:5px;");
                __builder.AddContent(seq++, ":");
                __builder.CloseElement();

                __builder.OpenElement(seq++, "span");
                __builder.AddAttribute(seq++, "style", $"color:{ThemeService.CurrentThemeSettings.PopupValueColor};");
                __builder.AddContent(seq++, value);
                __builder.CloseElement();

                if (hasComma)
                {
                    __builder.AddContent(seq++, ",");
                }

                __builder.CloseElement();
            }

            __builder.OpenElement(seq++, "div");
            __builder.AddContent(seq++, "}");
            __builder.CloseElement();
        }
    };

    private static List<(string, string, bool)> FormatJsonLines(string content)
    {
        if (string.IsNullOrWhiteSpace(content))
            return new List<(string, string, bool)>();

        var lines = content.Split('\n');
        var formattedLines = new List<(string, string, bool)>();

        for (int i = 0; i < lines.Length; i++)
        {
            var parts = lines[i].Split(new char[] { ':' }, 2, StringSplitOptions.RemoveEmptyEntries);

            if (parts.Length == 2)
            {
                var key = $"\"{parts[0].Trim()}\"";
                var value = parts[1].Trim();

                bool isString = false;
                bool boolResult;

                if (bool.TryParse(value, out boolResult))
                {
                    value = boolResult.ToString().ToLower();
                }
                else
                {
                    // Check if the value is not an int or double, thereby treating it as a string
                    isString = !int.TryParse(value, out _) && !double.TryParse(value, out _);

                    if (isString)
                    {
                        value = $"\"{value}\"";
                    }
                }

                bool isLast = i == lines.Length - 1;
                formattedLines.Add((key, value, !isLast));
            }
        }
        return formattedLines;
    }

    private string AddCurlyBracesAroundRoot(string input)
    {
        const string rootKeyword = "Root";
        if (input.StartsWith(rootKeyword))
        {
            return "{" + rootKeyword + "}" + input.Substring(rootKeyword.Length);
        }
        return input;
    }

    private async Task CopyNodeData(string data, bool isPath = false)
    {
        if (isPath)
        {
            await JS.InvokeVoidAsync("navigator.clipboard.writeText", AddCurlyBracesAroundRoot(data));
            isNodePathCopied = true;        
        }
        else
        {
            var formattedString = GetFormattedJsonString(data);
            await JS.InvokeVoidAsync("navigator.clipboard.writeText", formattedString);        
            isNodeContentCopied = true;
        }

        StateHasChanged();

        await Task.Delay(1500);

        StateHasChanged();

        if (isPath)
            isNodePathCopied = false;
        else
            isNodeContentCopied = false;
    }

    private static string GetFormattedJsonString(string content)
    {
        var formattedLines = FormatJsonLines(content);
        var result = "{\n";

        foreach (var (key, value, hasComma) in formattedLines)
        {
            result += $"    {key}: {value}{(hasComma ? "," : "")}\n";
        }

        result += "}";
        return result;
    }

    #endregion

    #region Nav Menu Actions

    private async Task HandleNavBarAction(string action)
    {
        switch (action)
        {
            case "import-json":
            case "export-json":
                await HandleImportExport(action);
                break;
            case "toggle-grid":
                ToggleGridLines();
                break;
            case "toggle-count":
                await ToggleItemCount();
                break;
            case "toggle-expand":
                await ToggleExpandCollapse();
                break;
            case "light":
            case "dark":
                await ToggleTheme(action);
                break;
        }

    }

    private async Task HandleImportExport(string action)
    {
        if (action == "import-json")
        {
            try
            {
                var objRef = DotNetObjectReference.Create(this);
                await JS.InvokeVoidAsync("importJsonFromFile", objRef);
            }
            catch (JSException ex)
            {
                Console.WriteLine("Import failed: " + ex.Message);
            }
        }
        else if (action == "export-json")
        {
            try
            {
                string jsonToExport = jsonValue ?? "{}";
                await JS.InvokeVoidAsync("exportJsonFile", jsonToExport, "Diagram.json");
            }
            catch (JSException ex)
            {
                Console.WriteLine("Export failed: " + ex.Message);
            }
        }
    }

    [JSInvokable]
    public async Task ReceiveImportedJson(string jsonContent)
    {
        jsonValue = jsonContent;
        await monacoEditor.SetValue(jsonContent);
    }

    private void ToggleGridLines()
    {
        if (snapConstraints == SnapConstraints.ShowLines)
            snapConstraints = SnapConstraints.None;
        else
            snapConstraints = SnapConstraints.ShowLines;
    }

    private async Task ToggleItemCount()
    {
        showChildCount = !showChildCount;
        await RefreshDiagramLayout();
    }

    private async Task ToggleExpandCollapse()
    {
        showExpandCollapseIcon = !showExpandCollapseIcon;
        await RefreshDiagramLayout();
    }

    private async Task ToggleTheme(string theme)
    {
        ThemeService.CurrentThemeSettings = new ThemeSettings(theme);

        await JS.InvokeVoidAsync("setTheme", ThemeService.CurrentThemeSettings.CssUrl);

        await UpdateDiagramElements();

        await monacoEditor.UpdateOptions(new EditorUpdateOptions()
        {
            Theme = $"vs-{theme}"
        });

        ThemeService.SetTheme(theme, ThemeService.CurrentThemeSettings);
    }

    private async Task UpdateDiagramElements()
    {
        await UpdateDefaultNodeStyles();

        foreach(Node node in diagram.Nodes)
        {
            if (node.Annotations != null || node.Annotations?.Count > 0)
            {
                foreach (var annotation in node.Annotations)
                {
                    string rawValue = annotation.Content?.ToString() ?? "";
                    ApplyAnnotationStyle(annotation, rawValue);
                }
            }
            if (node.ExpandIcon != null)
            {
                node.ExpandIcon.BorderColor = ThemeService.CurrentThemeSettings.ExpandIconBorder;
                node.ExpandIcon.Fill = ThemeService.CurrentThemeSettings.ExpandIconFillColor;                
            }
            if (node.CollapseIcon != null)
            {
                node.CollapseIcon.BorderColor = ThemeService.CurrentThemeSettings.ExpandIconBorder;
                node.CollapseIcon.Fill = ThemeService.CurrentThemeSettings.ExpandIconFillColor;
            }
        }
        
        foreach(Connector connector in diagram.Connectors)
        {
            UpdateConnectorStyle(connector);
        }

        await JS.InvokeVoidAsync("changeDiagramBackground", ThemeService.CurrentThemeSettings.DiagramBackgroundColor);
    }

    #endregion

    #region Hamburger Menu Actions

    private async Task HandleHamburgerMenuAction(string action)
    {
        switch (action)
        {
            case "export-image":
                exportDialog.Show();
                break;
            case "rotate-layout":
                await RotateDiagramLayout();
                break;
            case "expand-graph":
                await ToggleGraphCollapse();
                break;
        }
    }

    private async Task HandleExportDiagramAsImage()
    {
        var fileName = exportDialog.FileName;
        var format = exportDialog.ExportMode;
        DiagramExportSettings exportSettings = new DiagramExportSettings()
        {
            Region = DiagramPrintExportRegion.PageSettings,
        };
        if (!string.IsNullOrWhiteSpace(fileName) && Enum.TryParse(typeof(DiagramExportFormat), format, out var result))
        {
            DiagramExportFormat exportFormat = (DiagramExportFormat)result;
            await diagram.ExportAsync(fileName, exportFormat, exportSettings);
            exportDialog.Hide();
        }
    }

    private async Task ToggleGraphCollapse()
    {
        var nodes = diagram.Nodes;

        if (isGraphCollapsed)
        {
            // Expand all nodes
            foreach (var node in nodes)
            {
                // Check if a node is already expanded
                if (!node.IsExpanded)
                {
                    node.IsExpanded = true;
                }
            }
            // After expanding, reflect the new state
            isGraphCollapsed = false;
        }
        else
        {
            // Collapse only the root nodes
            var rootNodes = nodes.Where(node => node.InEdges.Count == 0).ToList();
            foreach (var node in rootNodes)
            {
                if (node.ID == "main-root")
                {
                    foreach (var edgeId in node.OutEdges)
                    {
                        var connector = diagram.Connectors.FirstOrDefault(c => c.ID == edgeId);
                        if (connector != null)
                        {
                            var targetNode = nodes.FirstOrDefault(n => n.ID == connector.TargetID);
                            if (targetNode != null)
                            {
                                targetNode.IsExpanded = false;
                            }
                        }
                    }
                }
                else
                {
                    node.IsExpanded = false;
                }
            }
            // After collapsing, reflect the new state
            isGraphCollapsed = true;
        }
        await RefreshDiagramLayout();
    }

    private async Task RotateDiagramLayout()
    {
        // Cycle through the orientations
        currentOrientationIndex = (currentOrientationIndex + 1) % orientationsList.Count();

        layoutOrientation = orientationsList[currentOrientationIndex];

        await RefreshDiagramLayout();
        diagram.FitToPage(new FitOptions() { Mode = FitMode.Both, Region = DiagramRegion.Content, CanZoomIn = true });
    }

    private async Task RefreshDiagramLayout()
    {
        await diagram.RefreshDataSourceAsync();
        await diagram.DoLayoutAsync();
    }

    #endregion

    #region Toolbar Actions

    private async Task HandleToolBarAction(string action)
    {
        switch (action)
        {
            case "reset":
                diagram.ResetZoom();
                break;
            case "fitToPage":
                diagram.FitToPage(new FitOptions() { Mode = FitMode.Both, Region = DiagramRegion.Content, CanZoomIn = true });
                break;
            case "zoomIn":
                diagram.Zoom(1.2, new DiagramPoint() { X = 100, Y = 100 });
                break;
            case "zoomOut":
                diagram.Zoom(1 / 1.2, new DiagramPoint() { X = 100, Y = 100 });
                break;
            default:
                await SearchNodes(action.Replace("search:", ""));
                break;
        }
    }

    private async Task SearchNodes(string searchText)
    {
        searchText = searchText.Trim().ToLower();
        var matchingNodes = new List<Node>();
        if (string.IsNullOrWhiteSpace(searchText))
        {
            await UpdateDefaultNodeStyles();
            return;
        }

        matchingNodes.Clear();
        diagram.ClearSelection();

        foreach (var node in diagram.Nodes)
        {
            string nodeText = node.Data.GetType().GetProperty("actualdata")?.GetValue(node.Data, null)?.ToString()?.ToLower();
            string contentId = node.ID + "_content";

            await SetNodeStyle(contentId, strokeColor: ThemeService.CurrentThemeSettings.NodeStrokeColor, ThemeService.CurrentThemeSettings.NodeFillColor, strokeWidth: "1.5");

            if (!string.IsNullOrEmpty(nodeText) && nodeText.Contains(searchText))
            {
                matchingNodes.Add(node);
            }
        }

        // Highlight matching nodes
        foreach (var node in matchingNodes)
        {
            string contentId = node.ID + "_content";
            await SetNodeStyle(contentId, strokeColor: "LightGreen", ThemeService.CurrentThemeSettings.HighlightColor, "2");
        }

    }

    private async Task SetNodeStyle(string domId, string strokeColor, string fillColor, string strokeWidth)
    {
        if (!string.IsNullOrEmpty(domId))
        {
            await JS.InvokeVoidAsync("setNodeStyle", domId, strokeColor, fillColor, strokeWidth);
        }
    }

    private async Task UpdateDefaultNodeStyles()
    {
        foreach (var node in diagram.Nodes)
        {
            string contentId = node.ID + "_content";
            await SetNodeStyle(contentId, strokeColor: ThemeService.CurrentThemeSettings.NodeStrokeColor, ThemeService.CurrentThemeSettings.NodeFillColor, strokeWidth: "1.5");
        }
    }

    #endregion
}

<style>
    html, body {
        height: 100%;
        margin: 0;
        padding: 0;
        overflow: hidden;
        font-family: Consolas,"Segoe UI", Tahoma, sans-serif;
    }

    .app-layout {
        display: grid;
        grid-template-rows: auto 1fr auto;
        height: 100vh;
        width: 100vw;
    }

    /* Top Nav */
    .navbar {
        z-index: 10;
    }

    /* Main Grid */
    .main-grid {
        display: grid;
        grid-template-columns: auto 6px 1fr;
        overflow: hidden;
    }

    /* Editor */
    .left-panel {
        height: 100%;
        overflow: hidden;
    }
    
    .left-panel.dark {
        background-color: #1e1e1e;
    }

    .json-editor {
        height: 100%;
    }

    /* Splitter */
    .splitter {
        background-color: transparent;
        cursor: col-resize;
        height: 100%;
    }

    .splitter.dark {
        background-color: #333;
    }

    /* Diagram */
    .right-panel {
        position: relative;
        width: 100%;
        height: 100%;
        overflow: hidden;
    }
    
    .right-panel.dark {
        background-color: #1e1e1e;
    }

    /* Bottom Bar */
    .bottom-bar {
        height: 20px;
        background-color: rgb(236, 236, 236);
        border-top: 1px solid #ccc;
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 0.74rem;
    }

    .bottom-bar-content {
        width: 100%;
        display: flex;
        align-items: center;
        padding: 0 20px;
        color: #333;
        gap: 20px;
    }

    .bottom-bar-content.dark {
        color: #eeee;
    }
    .bottom-right {
        margin-left: auto;
    }

    .status-message {
        display: flex;
        align-items: center;
        gap: 6px;
    }

    .status-icon {
        vertical-align: middle;
        margin-right: -2px;
    }

    .invalid-json {
        color: red;
    }

    .bottom-bar.dark {
        background-color: #212121;
        border-top: 1px solid rgb(77, 77, 77);
    }

    /* For WebKit-based browsers like Chrome and Safari */
    ::-webkit-scrollbar {
        width: 0px;
        height: 0px;
    }

    /* To hide scrollbars but keep scroll function */
    .scroll-hide {
        overflow: scroll;
        scrollbar-width: none; /* For Firefox */
        -ms-overflow-style: none; /* For IE and Edge */
    }

    .scroll-hide::-webkit-scrollbar {
        display: none; /* Hides scrollbar */
    }

    .e-diagram{
        background-color: #F8F9FA;
    }

</style>